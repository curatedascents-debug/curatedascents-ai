import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { blogPosts, blogCategories } from "@/db/schema";
import { eq, desc, and } from "drizzle-orm";
import { generateBlogPost, type BlogContentType } from "@/lib/blog/blog-writer-agent";
import { sendEmail } from "@/lib/email/send-email";
import BlogDraftNotificationEmail from "@/lib/email/templates/blog-draft-notification";

export const dynamic = "force-dynamic";

const DESTINATIONS = ["Nepal", "Bhutan", "Tibet", "India"];

const CONTENT_TYPES: BlogContentType[] = [
  "destination_guide",
  "travel_tips",
  "packing_list",
  "cultural_insights",
  "seasonal_content",
  "trip_report",
];

// Topic templates for each destination Ã— content type
const TOPIC_TEMPLATES: Record<string, Record<BlogContentType, string>> = {
  Nepal: {
    destination_guide: "The Ultimate Guide to Nepal: Luxury Adventures in the Himalayas",
    travel_tips: "Essential Travel Tips for a Luxury Nepal Adventure",
    packing_list: "What to Pack for a Luxury Trek in Nepal",
    cultural_insights: "Understanding Nepali Culture: A Luxury Traveler's Guide",
    seasonal_content: "Best Time to Visit Nepal: A Season-by-Season Guide",
    trip_report: "A Luxury Everest Base Camp Trek: Our Latest Expedition",
  },
  Bhutan: {
    destination_guide: "The Ultimate Guide to Bhutan: The Last Shangri-La",
    travel_tips: "Bhutan Travel Tips: Navigating the Land of the Thunder Dragon",
    packing_list: "Packing for Bhutan: Your Essential Luxury Travel Checklist",
    cultural_insights: "Bhutanese Culture & Festivals: What Every Traveler Should Know",
    seasonal_content: "When to Visit Bhutan: Seasonal Highlights & Festivals",
    trip_report: "A Journey Through Bhutan: Tigers Nest & Beyond",
  },
  Tibet: {
    destination_guide: "The Ultimate Guide to Tibet: Roof of the World Adventures",
    travel_tips: "Tibet Travel Tips: Essential Advice for the Roof of the World",
    packing_list: "Packing for Tibet: High-Altitude Essentials & Luxury Comforts",
    cultural_insights: "Tibetan Buddhist Culture: Sacred Traditions & Monastic Life",
    seasonal_content: "Best Time to Visit Tibet: Weather, Permits & Peak Seasons",
    trip_report: "A Luxury Journey Along the Friendship Highway",
  },
  India: {
    destination_guide: "Luxury India: From Rajasthan Palaces to Himalayan Retreats",
    travel_tips: "India Travel Tips for the Discerning Luxury Traveler",
    packing_list: "Packing for India: From Golden Triangle to Himalayan Treks",
    cultural_insights: "Indian Culture & Etiquette: A Guide for Luxury Travelers",
    seasonal_content: "Best Time to Visit India: Regional & Seasonal Guide",
    trip_report: "A Royal Rajasthan Journey: Palaces, Tigers & Desert Camps",
  },
};

function verifyCronSecret(request: NextRequest): boolean {
  const authHeader = request.headers.get("authorization");
  const cronSecret = process.env.CRON_SECRET;
  if (!cronSecret) {
    console.warn("CRON_SECRET not configured");
    return false;
  }
  return authHeader === `Bearer ${cronSecret}`;
}

// POST - Generate a new blog draft automatically
export async function POST(request: NextRequest) {
  if (!verifyCronSecret(request)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    // Find the most recent auto-generated post to determine the next combo
    const [lastAutoPost] = await db
      .select({
        contentType: blogPosts.contentType,
        promptUsed: blogPosts.promptUsed,
      })
      .from(blogPosts)
      .where(eq(blogPosts.isAutoGenerated, true))
      .orderBy(desc(blogPosts.createdAt))
      .limit(1);

    // Determine next destination + content type
    let destIdx = 0;
    let typeIdx = 0;

    if (lastAutoPost?.promptUsed) {
      // Parse the destination from the prompt
      const lastDest = DESTINATIONS.find((d) =>
        lastAutoPost.promptUsed?.toLowerCase().includes(d.toLowerCase())
      );
      const lastTypeIdx = CONTENT_TYPES.indexOf(
        lastAutoPost.contentType as BlogContentType
      );

      if (lastDest) {
        destIdx = DESTINATIONS.indexOf(lastDest);
      }

      // Advance to next combination
      typeIdx = lastTypeIdx + 1;
      if (typeIdx >= CONTENT_TYPES.length) {
        typeIdx = 0;
        destIdx = (destIdx + 1) % DESTINATIONS.length;
      }
    }

    const destination = DESTINATIONS[destIdx];
    const contentType = CONTENT_TYPES[typeIdx];
    const topic = TOPIC_TEMPLATES[destination][contentType];

    console.log(`[Auto Content] Generating: ${contentType} for ${destination}`);

    // Generate the blog post
    const draft = await generateBlogPost({
      topic,
      contentType,
      destination,
      targetLength: "medium",
    });

    // Find or use default category
    const [category] = await db
      .select({ id: blogCategories.id })
      .from(blogCategories)
      .where(eq(blogCategories.isActive, true))
      .limit(1);

    // Insert as draft
    const [newPost] = await db
      .insert(blogPosts)
      .values({
        title: draft.title,
        slug: draft.suggestedSlug,
        content: draft.content,
        excerpt: draft.excerpt,
        metaTitle: draft.metaTitle,
        metaDescription: draft.metaDescription,
        keywords: draft.keywords,
        tags: draft.tags,
        contentType,
        readTimeMinutes: draft.readTimeMinutes,
        status: "draft",
        isAutoGenerated: true,
        promptUsed: `${destination}: ${topic}`,
        authorName: "CuratedAscents AI",
        categoryId: category?.id || null,
      })
      .returning({ id: blogPosts.id });

    console.log(`[Auto Content] Draft created: ID ${newPost.id} - "${draft.title}"`);

    // Send admin notification
    const appUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    await sendEmail({
      to: "hello@curatedascents.com",
      subject: `New AI Blog Draft: ${draft.title}`,
      react: BlogDraftNotificationEmail({
        postTitle: draft.title,
        contentType,
        destination,
        excerpt: draft.excerpt,
        adminUrl: `${appUrl}/admin`,
      }),
      logContext: {
        templateType: "blog_draft_notification",
        metadata: { blogPostId: newPost.id, contentType, destination },
      },
    });

    return NextResponse.json({
      success: true,
      message: `Auto-generated blog draft: "${draft.title}"`,
      postId: newPost.id,
      destination,
      contentType,
    });
  } catch (error) {
    console.error("[Auto Content] Error:", error);
    return NextResponse.json(
      { error: "Failed to generate blog content" },
      { status: 500 }
    );
  }
}

// GET - Health check
export async function GET(request: NextRequest) {
  if (!verifyCronSecret(request)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const [lastAutoPost] = await db
      .select({
        title: blogPosts.title,
        createdAt: blogPosts.createdAt,
        contentType: blogPosts.contentType,
      })
      .from(blogPosts)
      .where(eq(blogPosts.isAutoGenerated, true))
      .orderBy(desc(blogPosts.createdAt))
      .limit(1);

    return NextResponse.json({
      success: true,
      lastAutoPost: lastAutoPost
        ? {
            title: lastAutoPost.title,
            createdAt: lastAutoPost.createdAt,
            contentType: lastAutoPost.contentType,
          }
        : null,
    });
  } catch (error) {
    console.error("[Auto Content] Health check error:", error);
    return NextResponse.json({ error: "Health check failed" }, { status: 500 });
  }
}
